{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from '../utilities/globals/index.js';\nimport { equal } from '@wry/equality';\nimport { execute } from '../link/core/index.js';\nimport { hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, removeDirectivesFromDocument } from '../utilities/index.js';\nimport { canonicalStringify } from '../cache/index.js';\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, canUseWeakMap, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform } from '../utilities/index.js';\nimport { mergeIncrementalData } from '../utilities/common/incrementalResult.js';\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from '../errors/index.js';\nimport { ObservableQuery, logMissingFieldErrors } from './ObservableQuery.js';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus.js';\nimport { LocalState } from './LocalState.js';\nimport { QueryInfo, shouldWriteResult } from './QueryInfo.js';\nimport { PROTOCOL_ERRORS_SYMBOL } from '../errors/index.js';\nimport { print } from '../utilities/index.js';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar QueryManager = function () {\n  function QueryManager(_a) {\n    var cache = _a.cache,\n      link = _a.link,\n      defaultOptions = _a.defaultOptions,\n      documentTransform = _a.documentTransform,\n      _b = _a.queryDeduplication,\n      queryDeduplication = _b === void 0 ? false : _b,\n      onBroadcast = _a.onBroadcast,\n      _c = _a.ssrMode,\n      ssrMode = _c === void 0 ? false : _c,\n      _d = _a.clientAwareness,\n      clientAwareness = _d === void 0 ? {} : _d,\n      localState = _a.localState,\n      _e = _a.assumeImmutableResults,\n      assumeImmutableResults = _e === void 0 ? !!cache.assumeImmutableResults : _e;\n    var _this = this;\n    this.clientAwareness = {};\n    this.queries = new Map();\n    this.fetchCancelFns = new Map();\n    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    this.inFlightLinkObservables = new Map();\n    var defaultDocumentTransform = new DocumentTransform(function (document) {\n      return _this.cache.transformDocument(document);\n    }, {\n      cache: false\n    });\n    this.cache = cache;\n    this.link = link;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({\n      cache: cache\n    });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = assumeImmutableResults;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;\n    if (this.onBroadcast = onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(newInvariantError(23));\n  };\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n  QueryManager.prototype.mutate = function (_a) {\n    var _b, _c;\n    var mutation = _a.mutation,\n      variables = _a.variables,\n      optimisticResponse = _a.optimisticResponse,\n      updateQueries = _a.updateQueries,\n      _d = _a.refetchQueries,\n      refetchQueries = _d === void 0 ? [] : _d,\n      _e = _a.awaitRefetchQueries,\n      awaitRefetchQueries = _e === void 0 ? false : _e,\n      updateWithProxyFn = _a.update,\n      onQueryUpdated = _a.onQueryUpdated,\n      _f = _a.fetchPolicy,\n      fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"network-only\" : _f,\n      _g = _a.errorPolicy,\n      errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || \"none\" : _g,\n      keepRootFields = _a.keepRootFields,\n      context = _a.context;\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationId, hasClientExports, mutationStoreValue, self;\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            invariant(mutation, 24);\n            invariant(fetchPolicy === 'network-only' || fetchPolicy === 'no-cache', 25);\n            mutationId = this.generateMutationId();\n            mutation = this.cache.transformForLink(this.transform(mutation));\n            hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n            variables = this.getVariables(mutation, variables);\n            if (!hasClientExports) return [3, 2];\n            return [4, this.localState.addExportedVariables(mutation, variables, context)];\n          case 1:\n            variables = _h.sent();\n            _h.label = 2;\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            if (optimisticResponse) {\n              this.markMutationOptimistic(optimisticResponse, {\n                mutationId: mutationId,\n                document: mutation,\n                variables: variables,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n                context: context,\n                updateQueries: updateQueries,\n                update: updateWithProxyFn,\n                keepRootFields: keepRootFields\n              });\n            }\n            this.broadcastQueries();\n            self = this;\n            return [2, new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: optimisticResponse\n              }), variables, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === 'none') {\n                  throw new ApolloError({\n                    graphQLErrors: getGraphQLErrorsFromResult(result)\n                  });\n                }\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n                var storeResult = __assign({}, result);\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n                if (errorPolicy === 'ignore' && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: optimisticResponse ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function (storeResult) {\n                  self.broadcastQueries();\n                  if (!('hasNext' in storeResult) || storeResult.hasNext === false) {\n                    resolve(storeResult);\n                  }\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n                  if (optimisticResponse) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: 'ROOT_MUTATION',\n          query: mutation.document,\n          variables: mutation.variables\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        var diff = cache.diff({\n          id: \"ROOT_MUTATION\",\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true\n        });\n        var mergedData = void 0;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== 'undefined') {\n          result.data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: 'ROOT_MUTATION',\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n      }\n      var updateQueries_1 = mutation.updateQueries;\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n          var updater = updateQueries_1[queryName];\n          var _b = _this.queries.get(queryId),\n            document = _b.document,\n            variables = _b.variables;\n          var _c = cache.diff({\n              query: document,\n              variables: variables,\n              returnPartialData: true,\n              optimistic: false\n            }),\n            currentQueryResult = _c.result,\n            complete = _c.complete;\n          if (complete && currentQueryResult) {\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n    if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function (cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          }\n          var update = mutation.update;\n          var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n          if (update) {\n            if (!skipCache) {\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                query: _this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n                if ('incremental' in result) {\n                  delete result.incremental;\n                }\n                if ('hasNext' in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables\n              });\n            }\n          }\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: 'ROOT_MUTATION',\n              fields: function (value, _a) {\n                var fieldName = _a.fieldName,\n                  DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        optimistic: false,\n        removeOptimistic: mutation.removeOptimistic,\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n    return Promise.resolve(result);\n  };\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables) : optimisticResponse;\n    return this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        globalThis.__DEV__ !== false && invariant.error(error);\n      }\n    }, mutation.mutationId);\n  };\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;\n  };\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n  QueryManager.prototype.transform = function (document) {\n    return this.documentTransform.transformDocument(document);\n  };\n  QueryManager.prototype.getDocumentInfo = function (document) {\n    var transformCache = this.transformCache;\n    if (!transformCache.has(document)) {\n      var cacheEntry = {\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives(['nonreactive'], document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument([{\n          name: 'client',\n          remove: true\n        }, {\n          name: 'connection'\n        }, {\n          name: 'nonreactive'\n        }], document),\n        defaultVars: getDefaultValues(getOperationDefinition(document)),\n        asQuery: __assign(__assign({}, document), {\n          definitions: document.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n            return def;\n          })\n        })\n      };\n      transformCache.set(document, cacheEntry);\n    }\n    return transformCache.get(document);\n  };\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n  };\n  QueryManager.prototype.watchQuery = function (options) {\n    var query = this.transform(options.query);\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    observable['lastQuery'] = query;\n    this.queries.set(observable.queryId, queryInfo);\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables\n    });\n    return observable;\n  };\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n    invariant(options.query, 26);\n    invariant(options.query.kind === 'Document', 27);\n    invariant(!options.returnPartialData, 28);\n    invariant(!options.pollInterval, 29);\n    return this.fetchQuery(queryId, __assign(__assign({}, options), {\n      query: this.transform(options.query)\n    })).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n  QueryManager.prototype.clearStore = function (options) {\n    if (options === void 0) {\n      options = {\n        discardWatches: true\n      };\n    }\n    this.cancelPendingFetches(newInvariantError(30));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n    return this.cache.reset(options);\n  };\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n    if (include === void 0) {\n      include = \"active\";\n    }\n    var queries = new Map();\n    var queryNamesAndDocs = new Map();\n    var legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(_this.transform(desc), false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n        document = _a.document;\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n        var queryName = oq.queryName,\n          fetchPolicy = oq.options.fetchPolicy;\n        if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n          return;\n        }\n        if (include === \"active\" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        var queryInfo = _this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n    if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n        if (!included) {\n          globalThis.__DEV__ !== false && invariant.warn(typeof nameOrDoc === \"string\" ? 31 : 32, nameOrDoc);\n        }\n      });\n    }\n    return queries;\n  };\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      _this.getQuery(queryId).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n  QueryManager.prototype.startGraphQLSubscription = function (_a) {\n    var _this = this;\n    var query = _a.query,\n      fetchPolicy = _a.fetchPolicy,\n      errorPolicy = _a.errorPolicy,\n      variables = _a.variables,\n      _b = _a.context,\n      context = _b === void 0 ? {} : _b;\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables).map(function (result) {\n        if (fetchPolicy !== 'no-cache') {\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables\n            });\n          }\n          _this.broadcastQueries();\n        }\n        var hasErrors = graphQLResultHasError(result);\n        var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          var errors = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          throw new ApolloError(errors);\n        }\n        return result;\n      });\n    };\n    if (this.getDocumentInfo(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n    return makeObservable(variables);\n  };\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n  QueryManager.prototype.removeQuery = function (queryId) {\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  };\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n    var _this = this;\n    var _a;\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n    var observable;\n    var _b = this.getDocumentInfo(query),\n      serverQuery = _b.serverQuery,\n      clientQuery = _b.clientQuery;\n    if (serverQuery) {\n      var _c = this,\n        inFlightLinkObservables_1 = _c.inFlightLinkObservables,\n        link = _c.link;\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        }))\n      };\n      context = operation.context;\n      if (deduplication) {\n        var printedServerQuery_1 = print(serverQuery);\n        var byVariables_1 = inFlightLinkObservables_1.get(printedServerQuery_1) || new Map();\n        inFlightLinkObservables_1.set(printedServerQuery_1, byVariables_1);\n        var varJson_1 = canonicalStringify(variables);\n        observable = byVariables_1.get(varJson_1);\n        if (!observable) {\n          var concast = new Concast([execute(link, operation)]);\n          byVariables_1.set(varJson_1, observable = concast);\n          concast.beforeNext(function () {\n            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {\n              inFlightLinkObservables_1.delete(printedServerQuery_1);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n    return observable;\n  };\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId();\n    var linkDocument = this.cache.transformForLink(options.query);\n    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n      var graphQLErrors = getGraphQLErrorsFromResult(result);\n      var hasErrors = graphQLErrors.length > 0;\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && options.errorPolicy === \"none\") {\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: graphQLErrors\n          }));\n        }\n        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: NetworkStatus.ready\n      };\n      if (hasErrors && options.errorPolicy !== \"ignore\") {\n        aqr.errors = graphQLErrors;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n      throw error;\n    });\n  };\n  QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, networkStatus) {\n    var _this = this;\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n    var query = options.query;\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var defaults = this.defaultOptions.watchQuery;\n    var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a,\n      _b = options.errorPolicy,\n      errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b,\n      _c = options.returnPartialData,\n      returnPartialData = _c === void 0 ? false : _c,\n      _d = options.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n      _e = options.context,\n      context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n    var fromVariables = function (variables) {\n      normalized.variables = variables;\n      var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n      if (normalized.fetchPolicy !== \"standby\" && sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return sourcesWithInfo;\n    };\n    var cleanupCancelFn = function () {\n      return _this.fetchCancelFns.delete(queryId);\n    };\n    this.fetchCancelFns.set(queryId, function (reason) {\n      cleanupCancelFn();\n      setTimeout(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast, containsDataFromLink;\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function (sourcesWithInfo) {\n        return sourcesWithInfo.sources;\n      }));\n      containsDataFromLink = true;\n    } else {\n      var sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n    return {\n      concast: concast,\n      fromLink: containsDataFromLink\n    };\n  };\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n    var updateCache = _a.updateCache,\n      include = _a.include,\n      _b = _a.optimistic,\n      optimistic = _b === void 0 ? false : _b,\n      _c = _a.removeOptimistic,\n      removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n      onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: _this.getQuery(queryId).getDiff()\n        });\n      });\n    }\n    var results = new Map();\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        optimistic: optimistic && removeOptimistic || false,\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function (watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n          if (oq) {\n            if (onQueryUpdated) {\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                result = oq.refetch();\n              }\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              return result;\n            }\n            if (onQueryUpdated !== null) {\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n          lastDiff = _a.lastDiff,\n          diff = _a.diff;\n        var result;\n        if (onQueryUpdated) {\n          if (!diff) {\n            var info = oq[\"queryInfo\"];\n            info.reset();\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  };\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, networkStatus) {\n    var _this = this;\n    var query = _a.query,\n      variables = _a.variables,\n      fetchPolicy = _a.fetchPolicy,\n      refetchWritePolicy = _a.refetchWritePolicy,\n      errorPolicy = _a.errorPolicy,\n      returnPartialData = _a.returnPartialData,\n      context = _a.context,\n      notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n    var readCache = function () {\n      return queryInfo.getDiff(variables);\n    };\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n      var data = diff.result;\n      if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n      if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      }\n      if (errorPolicy === 'none' && networkStatus === NetworkStatus.refetch && Array.isArray(diff.missing)) {\n        return fromData(void 0);\n      }\n      return fromData(data);\n    };\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 : 2;\n    var resultsFromLink = function () {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        query: query,\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n        };\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          sources: []\n        };\n    }\n  };\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId);\n  };\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign({}, newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n  return QueryManager;\n}();\nexport { QueryManager };","map":{"version":3,"sources":["../../src/core/QueryManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant, newInvariantError } from '../utilities/globals/index.js';\n\nimport type { DocumentNode } from 'graphql';\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from '@wry/equality';\n\nimport type { ApolloLink, FetchResult } from '../link/core/index.js';\nimport { execute } from '../link/core/index.js';\nimport {\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  removeDirectivesFromDocument,\n} from '../utilities/index.js';\nimport type { Cache, ApolloCache} from '../cache/index.js';\nimport { canonicalStringify } from '../cache/index.js';\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray} from '../utilities/index.js';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  canUseWeakMap,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from '../utilities/index.js';\nimport { mergeIncrementalData } from '../utilities/common/incrementalResult.js';\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from '../errors/index.js';\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n} from './watchQueryOptions.js';\nimport { ObservableQuery, logMissingFieldErrors } from './ObservableQuery.js';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus.js';\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n} from './types.js';\nimport { LocalState } from './LocalState.js';\n\nimport type {\n  QueryStoreValue} from './QueryInfo.js';\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from './QueryInfo.js';\nimport type { ApolloErrorOptions } from '../errors/index.js';\nimport { PROTOCOL_ERRORS_SYMBOL } from '../errors/index.js';\nimport { print } from '../utilities/index.js';\n\nconst { hasOwnProperty } = Object.prototype;\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\ntype DefaultOptions = import(\"./ApolloClient.js\").DefaultOptions;\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    defaultOptions,\n    documentTransform,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults = !!cache.assumeImmutableResults,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    defaultOptions?: DefaultOptions;\n    documentTransform?: DocumentTransform;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = cache;\n    this.link = link;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = assumeImmutableResults;\n    this.documentTransform = documentTransform\n      ? defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform\n\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError('QueryManager stopped while query was in flight'),\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<TData>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache',\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    if (optimisticResponse) {\n      this.markMutationOptimistic<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      >(optimisticResponse, {\n        mutationId,\n        document: mutation,\n        variables,\n        fetchPolicy,\n        errorPolicy,\n        context,\n        updateQueries,\n        update: updateWithProxyFn,\n        keepRootFields,\n      });\n    }\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse,\n          },\n          variables,\n          false,\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(storeResult);\n          }\n\n          if (errorPolicy === 'ignore' &&\n              graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<\n            TData,\n            TVariables,\n            TContext,\n            TCache\n          >({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: optimisticResponse ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        },\n\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!('hasNext' in storeResult) || storeResult.hasNext === false) {\n            resolve(storeResult);\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache,\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: 'ROOT_MUTATION',\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== 'undefined') {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: 'ROOT_MUTATION',\n            query: mutation.document,\n            variables: mutation.variables,\n          })\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      mutation.refetchQueries ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache: TCache) => {\n          if (!skipCache) {\n            cacheWrites.forEach(write => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...result as FetchResult, data: diff.result };\n                if ('incremental' in result) {\n                  delete result.incremental;\n                }\n                if ('hasNext' in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: 'ROOT_MUTATION',\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n\n      }).forEach(result => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<TData, TVariables, TContext, TCache extends ApolloCache<any>>(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>,\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean,\n    },\n  ) {\n    const data = typeof optimisticResponse === \"function\"\n      ? optimisticResponse(mutation.variables)\n      : optimisticResponse;\n\n    return this.cache.recordOptimisticTransaction(cache => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>({\n          ...mutation,\n          result: { data },\n        }, cache);\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(\n      queryId,\n      options,\n      networkStatus,\n    ).concast.promise;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new (\n    canUseWeakMap ? WeakMap : Map\n  )<DocumentNode, TransformCacheEntry>();\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives(['nonreactive'], document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument([\n          { name: 'client', remove: true },\n          { name: 'connection' },\n          { name: 'nonreactive' },\n        ], document),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map(def => {\n            if (def.kind === \"OperationDefinition\" &&\n                def.operation !== \"query\") {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        }\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables,\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<T, TVariables extends OperationVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(\n        query,\n        options.variables,\n      ) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable['lastQuery'] = query;\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId(),\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return this.fetchQuery<TData, TVars>(\n      queryId,\n      { ...options, query: this.transform(options.query) },\n    ).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(options: Cache.ResetOptions = {\n    discardWatches: true,\n  }): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(newInvariantError(\n      'Store reset while query was in flight (not completed in link chain)',\n    ));\n\n    this.queries.forEach(queryInfo => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\",\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNamesAndDocs = new Map<string | DocumentNode, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach(desc => {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(this.transform(desc), false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndDocs.has(queryName)) ||\n          (document && queryNamesAndDocs.has(document))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach((included, nameOrDoc) => {\n        if (!included) {\n          invariant.warn(typeof nameOrDoc === \"string\" ? `Unknown query named \"%s\" requested in refetchQueries options.include array` : `Unknown query %s requested in refetchQueries options.include array`, nameOrDoc);\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(\n      includeStandby ? \"all\" : \"active\"\n    ).forEach((observableQuery, queryId) => {\n      const { fetchPolicy } = observableQuery.options;\n      observableQuery.resetLastResults();\n      if (includeStandby ||\n          (fetchPolicy !== \"standby\" &&\n           fetchPolicy !== \"cache-only\")) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      this.getQuery(queryId).setDiff(null);\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy,\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        context,\n        variables,\n      ).map(result => {\n        if (fetchPolicy !== 'no-cache') {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        const hasErrors = graphQLResultHasError(result);\n        const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          const errors: ApolloErrorOptions = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          throw new ApolloError(errors);\n        }\n\n        return result;\n      });\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n        context,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(info => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Map<\n    string,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean =\n      // Prefer context.queryDeduplication if specified.\n      context?.queryDeduplication ??\n      this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const byVariables = inFlightLinkObservables.get(printedServerQuery) || new Map();\n        inFlightLinkObservables.set(printedServerQuery, byVariables);\n\n        const varJson = canonicalStringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>\n          ]);\n\n          byVariables.set(varJson, observable = concast);\n\n          concast.beforeNext(() => {\n            if (byVariables.delete(varJson) &&\n                byVariables.size < 1) {\n              inFlightLinkObservables.delete(printedServerQuery);\n            }\n          });\n        }\n\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>\n        ]);\n      }\n    } else {\n      observable = new Concast([\n        Observable.of({ data: {} } as FetchResult<T>)\n      ]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<WatchQueryOptions<TVars, TData>,\n      | \"query\"\n      | \"variables\"\n      | \"context\"\n      | \"fetchPolicy\"\n      | \"errorPolicy\">,\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = queryInfo.lastRequestId = this.generateRequestId();\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables,\n      ),\n\n      result => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(new ApolloError({\n              graphQLErrors,\n            }));\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      networkError => {\n        const error = isApolloError(networkError)\n          ? networkError\n          : new ApolloError({ networkError });\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      },\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading\n  ): ConcastAndInfo<TData> {\n    const { query } = options;\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = defaults && defaults.fetchPolicy || \"cache-first\",\n      errorPolicy = defaults && defaults.errorPolicy || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus,\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryId);\n    this.fetchCancelFns.set(queryId, reason => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n        containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(normalized.query, normalized.variables, normalized.context)\n          .then(fromVariables).then(sourcesWithInfo => sourcesWithInfo.sources),\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<ApolloCache<TStore>, TResult>\n  ): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<string, {\n      oq: ObservableQuery<any>;\n      lastDiff?: Cache.DiffResult<any>;\n      diff?: Cache.DiffResult<any>;\n    }>();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map;\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo &&\n            watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result: TResult | boolean | Promise<ApolloQueryResult<any>> | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    { query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff(variables);\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading,\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ &&\n          !returnPartialData &&\n          !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) => Observable.of({\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n        ...(diff.complete ? null : { partial: true }),\n      } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState.runResolvers({\n          document: query,\n          remoteResult: { data },\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n        }).then(resolved => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === 'none' &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID :\n      ( // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ? CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () => this.getResultsFromLink<TData, TVars>(\n      queryInfo,\n      cacheWriteBehavior,\n      {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      },\n    );\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:  case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return { fromLink: false, sources: [resultsFromCache(diff, queryInfo.markReady())] };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return { fromLink: true, sources: [resultsFromCache(diff), resultsFromLink()] };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return { fromLink: true, sources: [resultsFromCache(diff), resultsFromLink()] };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return { fromLink: false, sources: [resultsFromCache(readCache(), queryInfo.markReady())] };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return { fromLink: true, sources: [resultsFromCache(readCache()), resultsFromLink()] };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [\n              resultsFromCache(queryInfo.getDiff()),\n              resultsFromLink(),\n            ],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}